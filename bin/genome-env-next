#!/bin/bash

set -o errexit
set -o pipefail

function usage {
    sed 's/^\ \{4\}//' <<EOS
    usage: $THIS [-hsuw] [command args]
        See \`$THIS -h' for detailed help.
EOS
}

function help {
    sed 's/^\ \{4\}//' <<EOS
    NAME - $THIS

    DESCRIPTION
    ===========

    \`$THIS' is used as a wrapper command to setup an environment for \`genome'.  For most use cases no options need to be specified.  For example,

        $THIS genome --help

    If you know you will need to run several commands in succession you can start a new shell by doing,

        $THIS \$SHELL

    OPTIONS
    =======

    -h    Display this detailed help.

    -M    Disable migration of database.

    -S    Disable configuration of database.

    -s db_snapshot_name
          The name of the database snapshot to use instead of the default.

    -U    Disable configuration of UR.

    -u ur_repo
          The path to a UR repo to use instead of the default.

    -v    Enable verbose status messages.

    -W    Disable configuration of Workflow.

    -w workflow_repo
          The path to a Workflow repo to use instead of the default.
EOS
}

function main {
    local TESTDBSERVER_DB_NAME TESTDBSERVER_DB_HOST TESTDBSERVER_DB_PORT \
        TESTDBSERVER_DB_USER="genome" \
        TESTDBSERVER_DB_PASS="mypassword"

    local DISABLE_DB DISABLE_MIGRATIONS DISABLE_UR DISABLE_WF
    local SNAPSHOT_NAME TOP UR_REPO VERBOSE WF_REPO

    if $GIT rev-parse --is-inside-work-tree 1> /dev/null 2> /dev/null
    then
        TOP="$($GIT rev-parse --show-toplevel)"
    else
        TOP="$PWD"
    fi

    export TESTDBSERVER_URL="https://apipe-test-db.gsc.wustl.edu"

    parse_opts "$@"
    shift $((OPTIND-1))

    rebuild_meta_db
    setup_test_db "$TOP"
    setup_env "$TOP"

    log.info ''
    log.info "Genome Perl: $(genome-perl -e 'printf(qq(%vd\n), $^V)')"
    log.info "Genome Prove: $(genome-prove --version)"
    for MODULE in UR Workflow Genome
    do
        log.info "${MODULE}: $(genome-perl -M$MODULE -e "print \$INC{q(${MODULE}.pm)}, qq(\n)")"
    done
    log.info "Test DB Snapshot: $SNAPSHOT_NAME"
    log.info "Test DB Name: $TESTDBSERVER_DB_NAME"
    log.info ''

    if test "$#" -gt 0
    then
        log.info "$@"...
        exec "$@"
    else
        if test -n "$BASH"
        then
            echo 'Press <Ctrl>-D or type `logout` to return to normal environment.'
            echo ''
            unset PROMPT_COMMAND
            export PS1="(${GE_ENV_NAME}) \w $ "
            exec "$BASH" --norc --noprofile
        else
            fatal $DEP_ERR 'only `bash` shells are supported at this time'
        fi
    fi
}

function parse_opts {
    DISABLE_DB="" DISABLE_MIGRATIONS="" DISABLE_UR="" DISABLE_WF="" SNAPSHOT_NAME="" UR_REPO="" WF_REPO=""

    local opts
    while getopts :hMSs:Uu:vWw: opts "$@"
    do
        case $opts in
            h)
                help
                exit 0
                ;;
            M)
                DISABLE_MIGRATIONS="TRUE"
                ;;
            S)
                DISABLE_DB="TRUE"
                ;;
            s)
                SNAPSHOT_NAME="$OPTARG"
                ;;
            U)
                DISABLE_UR="TRUE"
                ;;
            u)
                UR_REPO="$OPTARG"
                ;;
            v)
                VERBOSE="TRUE"
                ;;
            W)
                DISABLE_WF="TRUE"
                ;;
            w)
                WF_REPO="$OPTARG"
                ;;
            :)
                fatal $OPT_ERR "option -$OPTARG requires an argument"
                ;;
            \?)
                fatal $OPT_ERR "illegal option -- $OPTARG"
                ;;
        esac
    done

    validate_opts
    set_defaults
}

function validate_opts {
    if test -n "$DISABLE_DB" -a -n "$DISABLE_MIGRATIONS"
    then
        fatal $OPT_ERR "cannot use -S and -M options together"
    fi

    if test -n "$DISABLE_DB" -a -n "$SNAPSHOT_NAME"
    then
        fatal $OPT_ERR "cannot use -S and -s options together"
    fi

    if test -n "$DISABLE_UR" -a -n "$UR_REPO"
    then
        fatal $OPT_ERR "cannot use -U and -u options together"
    fi

    if test -n "$DISABLE_WF" -a -n "$WF_REPO"
    then
        fatal $OPT_ERR "cannot use -W and -w options together"
    fi

    if test -n "$SNAPSHOT_NAME"
    then
        if ! $TESTDB template list | cut -f 1 | $GREP -q "^${SNAPSHOT_NAME}$"
        then
            fatal $OPT_ERR "invalid snapshot name -- $SNAPSHOT_NAME"
        fi
    fi

    if test -n "$UR_REPO"
    then
        assert_dir "-u" "$UR_REPO"
    fi

    if test -n "$WF_REPO"
    then
        assert_dir "-w" "$WF_REPO"
    fi
}

function assert_dir {
    if ! test -d "$2"
    then
        fatal $OPT_ERR "$1 value must be a directory -- $2"
    fi
}

function set_defaults {
    local SUBMODULES=()

    if test -z "$SNAPSHOT_NAME"
    then
        SNAPSHOT_NAME="82f3e4d"
    fi

    if test -z "$UR_REPO"
    then
        if test -z "$TOP" -o ! -d "$TOP/ur"
        then
            fatal $OPT_ERR "-u must be specified if not in a Genome repo"
        fi
        SUBMODULES=(ur)
        UR_REPO="$TOP/ur"
    fi

    if test -z "$WF_REPO"
    then
        if test -z "$TOP" -o ! -d "$TOP/workflow"
        then
            fatal $OPT_ERR "-w must be specified if not in a Genome repo"
        fi
        SUBMODULES=("${SUBMODULES[@]}" workflow)
        WF_REPO="$TOP/workflow"
    fi

    if test "${#SUBMODULES}" -gt 0
    then
        prepare_submodules "${SUBMODULES[@]}"
    fi
}

function __quiet_git {
    (
        set +o errexit
        OUT="$($GIT "$@" 2>&1)"
        GIT_EXIT=$?
        if test $GIT_EXIT -ne 0
        then
            fatal $BUILD_ERR -e "$OUT"
        fi
    )
}

DEP_ERR=1 # 1 = dependency error
OPT_ERR=2 # 2 = option error
BUILD_ERR=3 # 3 = build error
function fatal {
    EXIT="$1"
    shift
    log.error "$@"
    exit $EXIT
}

function log.error {
    echo "$THIS: $@" >&2
}

function log.info {
    echo "$@" 1>&2
}

function prepare_submodules {
    (
        log.info -e "\n=> Preparing Submodules..."
        cd "$($GIT rev-parse --show-cdup)"

        __quiet_git submodule sync "$@"

        for submodule in "$@"
        do
            log.info -n "   $submodule: "
            if $GIT submodule status $submodule | $GREP -q ^-
            then
                __quiet_git submodule update --init $submodule
                log.info "OK"
            else
                (
                    EXPECTED_HEAD=$($GIT ls-tree HEAD $submodule | awk '{print $3}')
                    cd $submodule
                    HEAD=$($GIT rev-parse HEAD)

                    if ! $GIT cat-file -e $EXPECTED_HEAD
                    then
                        __quiet_git fetch --all
                    fi

                    if ! $GIT status --porcelain | $GREP -q . \
                        && $GIT merge-base --is-ancestor $HEAD $EXPECTED_HEAD
                    then
                        cd - 1> /dev/null
                        __quiet_git submodule update --init $submodule
                        log.info "OK"
                    else
                        fatal $BUILD_ERR "submodule has local changes"
                    fi
                )
            fi
        done
    )
}

function regen_db {
    local DB_TXT="$1"
    log.info -n '.'
    DB_BIN=${DB_TXT/-dump/}
    if test "$DB_BIN" -ot "$DB_TXT"
    then
        rm -f "$DB_BIN"
        $SQLITE3 "$DB_BIN" < "$DB_TXT"
    fi
}

function rebuild_meta_db {
    log.info -en "\n=> Rebuilding Meta DB..."

    if $GIT rev-parse --is-inside-work-tree 1> /dev/null 2> /dev/null
    then
        # ls-files is fast but then we have to also query submodules
        # foreach defines $name which serves to prefix the submodule path
        ( $GIT ls-files \
            && $GIT submodule foreach "$GIT ls-files | sed \"s|^|\$name/|\"" ) \
        | $GREP -P '\.sqlite3n?-dump$' \
        | while read DB_TXT
        do
            regen_db "$DB_TXT"
        done
    else
        find "$PWD" -iname '*sqlite3-dump' -or -iname '*sqlite3n-dump' | while read DB_TXT; do
            regen_db "$DB_TXT"
        done
    fi

    log.info ' done'
}

function setup_test_db {
    local BASE_DIR="$1"
    echo "=> Creating test database..."
    eval "$($TESTDB database create --bash --owner $TESTDBSERVER_DB_USER --based-on $SNAPSHOT_NAME)"
    if test -z "$TESTDBSERVER_DB_NAME"
    then
        fatal $BUILD_ERR "failed to create test database"
    fi

    if test -z "$DISABLE_MIGRATIONS"
    then
        echo "=> Migrating test database..."
        (
            cd "$BASE_DIR/sqitch/gms"
            $SQITCH config core.pg.host     $TESTDBSERVER_DB_HOST
            $SQITCH config core.pg.username $TESTDBSERVER_DB_USER
            $SQITCH config core.pg.password $TESTDBSERVER_DB_PASS
            $SQITCH config core.pg.db_name  $TESTDBSERVER_DB_NAME
            if ! $SQITCH status | grep -q 'Nothing to deploy'
            then
                $SQITCH deploy
            fi
        )
    fi
}

function setup_env {
    log.info -e "\n=> Setting Up Test Environment..."

    local BIN MODULE \
        BASE_DIR="$1" \
        SNAPSHOT_LIB="/gsc/scripts/opt/genome/current/user/lib/perl" \
        SNAPSHOT_BIN="/gsc/scripts/opt/genome/current/user/bin"

    # remove deployed bin directory from PATH
    PATH="$(echo $PATH | tr : "\n" | $GREP -v "$SNAPSHOT_BIN" | tr '\n' : | sed 's/:$//')"
    PATH=$UR_REPO/bin:$PATH
    PATH=$WF_REPO/bin:$PATH
    PATH=$BASE_DIR/bin:$PATH
    export PATH

    # remove deployed lib/perl directory from PATH
    PERL5LIB="$(echo $PERL5LIB | tr : "\n" | $GREP -v "$SNAPSHOT_LIB" | tr '\n' : | sed 's/:$//')"

    for MODULE in UR Workflow Genome
    do
        if genome-perl -M$MODULE -e 1 2> /dev/null
        then
            fatal $BUILD_ERR "still found $MODULE after removing deployed snapshot"
        fi
    done

    PERL5LIB=$UR_REPO/lib:$PERL5LIB
    PERL5LIB=$BASE_DIR/configuration-manager/lib:$PERL5LIB
    PERL5LIB=$WF_REPO/lib:$PERL5LIB
    PERL5LIB=$BASE_DIR/lib/perl:$PERL5LIB
    export PERL5LIB

    GENOME_CONFIG_PATH=$BASE_DIR/gms-confg/etc/gms

    for MODULE in UR Workflow Genome
    do
        if ! genome-perl -M$MODULE -e 1 2> /dev/null
        then
            fatal $BUILD_ERR "failed to load $MODULE"
        fi
    done

    for BIN in ur workflow genome
    do
        if which $BIN | $GREP -q "$SNAPSHOT_BIN"
        then
            fatal $BUILD_ERR "$BIN found in $SNAPSHOT_BIN"
        fi
    done

    export GENOME_DS_GMSCHEMA_SERVER="dbname=${TESTDBSERVER_DB_NAME};host=${TESTDBSERVER_DB_HOST};port=${TESTDBSERVER_DB_PORT}"
    export GENOME_DS_GMSCHEMA_LOGIN=$TESTDBSERVER_DB_USER
    export GENOME_DS_GMSCHEMA_AUTH=$TESTDBSERVER_DB_PASS

    hash -r
}

THIS="$(basename "$0")"

GIT="$(type -p git)" || fatal $DEP_ERR "git is required"
SQITCH="$(type -p sqitch)" || fatal $DEP_ERR "sqitch is required"
SQLITE3="$(type -p sqlite3)" || fatal $DEP_ERR "sqlite3 is required"
GREP="$(type -p grep)" || fatal $DEP_ERR "grep is required"
TESTDB="$(type -p test-db)" || fatal $DEP_ERR "test-db is required"

if test -z "$GE_ENV_NAME"
then
    GE_ENV_NAME="genome-env"
fi

if test -z "$STOP_GENOME_ENV_REDIRECT"
then
    # delegate to local version if it is found
    if $GIT rev-parse --is-inside-work-tree 1> /dev/null 2> /dev/null
    then
        WORK_TREE="$($GIT rev-parse --show-toplevel)"
        NEW_THIS="${WORK_TREE}/bin/${THIS}"
        if test -x "$NEW_THIS"
        then
            export STOP_GENOME_ENV_REDIRECT=1
            exec "$NEW_THIS" "$@"
        fi
    fi
fi

set -o nounset

main "$@"
