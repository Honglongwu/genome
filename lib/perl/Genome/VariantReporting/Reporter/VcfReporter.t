#!/usr/bin/env genome-perl

BEGIN { 
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
}

use strict;
use warnings;

use above "Genome";
use Test::More;
use Genome::Utility::Test qw(compare_ok);
use Set::Scalar;

my $pkg = 'Genome::VariantReporting::Reporter::VcfReporter';
use_ok($pkg);

my $factory = Genome::VariantReporting::Framework::Factory->create();
isa_ok($factory->get_class('reporters', $pkg->name), $pkg);

my $indel_filter_pkg = 'Genome::VariantReporting::Generic::ContainsTagFilter';
use_ok($indel_filter_pkg);

my $ft_filter_pkg = 'Genome::VariantReporting::Generic::FTKeepFilter';
use_ok($ft_filter_pkg);

test_reporter();

done_testing;

sub create_vcf_header {
    my $header_txt = <<EOS;
##fileformat=VCFv4.1
#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	S1	S2	S3	S4	S5
EOS
    my @lines = split("\n", $header_txt);
    my $header = Genome::File::Vcf::Header->create(lines => \@lines);
    return $header
}

sub create_entry {
    my @fields = (
        '1',            # CHROM
        10,             # POS
        '.',            # ID
        'A',           # REF
        'C,AT,T',     # ALT
        '.',            # QUAL
        '.',         # FILTER
        '.',  # INFO
        'GT:DP',     # FORMAT
        "1/1:12",   # S1
        "0/1:12",   # S2
        "1/2:12",   # S3
        "0/0:12",   # S4
        '.'         # S5
    );

    my $entry_txt = join("\t", @fields);
    my $entry = Genome::File::Vcf::Entry->new(create_vcf_header(), $entry_txt);
    return $entry;
}


sub test_reporter {
    my $reporter = Genome::VariantReporting::Reporter::VcfReporter->create(file_name => 'vcf');
    ok($reporter, "Reporter created successfully");

    my $indel_filter = $indel_filter_pkg->create(info_tag => 'ON_TARGET');
    ok($indel_filter->isa($indel_filter_pkg), 'Filter created successfully');
    $reporter->add_interpreter_object($indel_filter);

    my $ft_filter = $ft_filter_pkg->create(sample_name => 'S1');
    ok($ft_filter->isa($ft_filter_pkg), 'Filter created successfully');
    $reporter->add_interpreter_object($ft_filter);

    my $expected_filters = Set::Scalar->new($indel_filter, $ft_filter);
    my $actual_filters = Set::Scalar->new($reporter->filter_interpreters);
    ok($actual_filters->is_equal($expected_filters), 'Filter interpreter list as expected');

    my $entry = create_entry();
    $reporter->add_headers_for_soft_filters($entry->{header});
    $reporter->add_header_for_main_filter($entry->{header});
    my $expected_filter_ids = Set::Scalar->new(keys %{$entry->{header}->filters});
    for my $filter ($reporter->filter_interpreters) {
        ok($expected_filter_ids->contains($filter->vcf_id), sprintf('Header containts FILTER tag for %s interpreter: %s', $filter->name, $filter->vcf_id));
    }
    $reporter->header($entry->{header});

    my %interpretations = (
        $indel_filter->name => {
            C  => { filter_status => 1, },
            AT => { filter_status => 1, },
            T  => { filter_status => 0, },
        },
        $ft_filter->name => {
            C  => { filter_status => 1, },
            AT => { filter_status => 0, },
            T  => { filter_status => 0, },
        },
    );
    my @final_results = $reporter->determine_final_results(\%interpretations, $entry);
    is_deeply(\@final_results, [1, 0, 0], "Final filter results as expected");
    Genome::VariantReporting::Reporter::VcfReporter::add_final_results($entry, @final_results);
    is($entry->info('ALLFILTERSPASS'), '1,0,0', 'ALLFILTERPASS INFO field added correctly');
}
