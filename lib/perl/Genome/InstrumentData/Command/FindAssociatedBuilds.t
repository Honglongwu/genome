#!/usr/bin/env genome-perl

BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
}

use strict;
use warnings;

use above "Genome";

use Test::More;

use_ok('Genome::InstrumentData::Command::FindAssociatedBuilds') or die;

# setup the instrument_data, models and builds
my $test_id = create_instrument_data();

my $num_models = 4;
my @models = create_models($num_models);
my $parent_model = $models[0];

$parent_model->add_instrument_data($test_id);
is($parent_model->instrument_data, $test_id, 'found instrument data on parent model');

my $num_builds_per_model = 4;
my @builds = create_builds($num_builds_per_model, @models);

# check that it finds the correct builds
my @found_builds = Genome::InstrumentData::Command::FindAssociatedBuilds::_find_builds($test_id, 20);
my %build_hash = map {$_->id, $_} @builds;
my %found_hash = map {$_->id, $_} @found_builds;
is_deeply(\%build_hash, \%found_hash, 'found all builds associated with test instrument data');

# check that it dies if it exceeds the maximum number of iterations
eval {
    Genome::InstrumentData::Command::FindAssociatedBuilds::_find_builds($test_id, 2);
};
ok($@ =~ 'Exceeded maximum number of related build iterations.', 'died as expected');


done_testing();


sub create_instrument_data {
    my $sample = Genome::Sample->create(
        name => 'test sample'
    );

    my $library = Genome::Library->create(
        sample_id => $sample->id,
        name => 'test library',
    );

    class Genome::InstrumentData::Test {
        is => 'Genome::InstrumentData',
    };

    my $test_id = Genome::InstrumentData::Test->create(
        sequencing_platform => 'test',
        library_id => $library->id,
    );
    ok($test_id, 'created test instrument data') or die;
    return $test_id;
}

# create a chain of models, where each one (except the first) has
# an input which is the previous one.
sub create_models {
    my ($num_models) = @_;
    $num_models = 2 if $num_models < 2;

    # processing profile
    class Genome::ProcessingProfile::Test {
        is => 'Genome::ProcessingProfile'
    };
    my $test_pp = Genome::ProcessingProfile::Test->create(
        name => 'test_pp',
    );
    ok($test_pp, 'created test processing profile') or die;


    # subject
    class Genome::Subject::Test {
        is => 'Genome::Subject'
    };
    my $test_subject = Genome::Subject::Test->create(
        name => 'test_subject'
    );
    ok($test_subject, 'created test subject') or die;


    # models
    class Genome::TestModel {
        is => 'Genome::Model',
        has => [
            previous_model => {
                is => 'Genome::Model',
                is_optional => 1,
                is_input => 1,
            },
        ],
    };

    my $parent_model = Genome::TestModel->create(
        name => 'm1',
        processing_profile => $test_pp,
        subject => $test_subject,
    );
    ok($parent_model, 'created parent model') or die;

    my @models = ($parent_model);
    for my $i (2..$num_models) {
        my $model = Genome::TestModel->create(
            name => "m$i",
            processing_profile => $test_pp,
            subject => $test_subject,
            previous_model => $models[-1],
        );
        push @models, $model;
        ok($model, "created m$i") or die;
    }
    return @models;
}


# for each model create builds and set their status to completed.
sub create_builds {
    my ($num_builds_per_model, @models) = @_;

    class Genome::Model::Build::Test {
        is => 'Genome::Model::Build',
    };

    my @builds;
    for my $model (@models) {
        for my $i (1..$num_builds_per_model) {
            my $build = Genome::Model::Build::Test->create(
                model => $model,
            );
            $build->status('Succeeded');
            push @builds, $build;
            ok($build, "created test build $i for model " . $model->id) or die;
        }
    }
    return @builds;
}
