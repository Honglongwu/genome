#!/usr/bin/env genome-perl
use strict;
use warnings;

# shouldn't be necessary for this test, but included just in case
BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
};

use Test::More;
use above "Genome";

use Genome::Utility::Test qw(compare_ok);
use File::Basename;

my $class = 'Genome::Model::Tools::Bwa';
use_ok($class);

# helpers
sub _has_key {
    my $hash = shift;
    my $key = shift;
    die "Not a hash ref" unless ref $hash eq 'HASH';
    return grep { $key eq $_ } keys %$hash;
}

my %custom_versions = (
    'invalid-key' => {
        path       => '/path/to/bwa',
        features   => [],
        log_format => 'old',
        index_type => 'includes_reverse',
        crashes    => 'yes',
    },
    'missing-keys' => {
        path       => '/path/to/bwa',
    },
    'invalid-features' => {
        path       => '/path/to/bwa',
        features   => ['foo', 'bar'],
        log_format => 'old',
        index_type => 'includes_reverse',
    },
    'invalid-log-format' => {
        path       => '/path/to/bwa',
        features   => [],
        log_format => 'foo',
        index_type => 'includes_reverse',
    },
    'invalid-index-type' => {
        path       => '/path/to/bwa',
        features   => [],
        log_format => 'old',
        index_type => 'foo',
    },
    'all-features-new-logs-skips-reverse' => {
        path       => '/path/to/bwa',
        features   => ['bam_input', 'multiple_reference_mode', 'mem', 'bwasw'],
        log_format => 'new',
        index_type => 'skips_reverse',
    },
    'no-features-old-logs-includes-reverse' => {
        path       => '/path/to/bwa',
        features   => [],
        log_format => 'old',
        index_type => 'includes_reverse',
    },
);

# tests
sub test_lookup_version {
    # these tests assume there is a 'bwa' version included in the module

    # test _lookup_version in scalar context
    my $scalar;

    $scalar = $class->_lookup_version('bwa');
    ok(_has_key($scalar, 'path'), 'Single Bwa version in scalar context');

    $scalar = $class->_lookup_version();
    ok(_has_key($scalar, 'bwa'), 'All Bwa versions in scalar context');

    $scalar = $class->_lookup_version('foo');
    is($scalar, undef, 'Invalid version is undef in scalar context');

    # test _lookup_version in scalar context
    my %hash;

    %hash = $class->_lookup_version('bwa');
    ok(_has_key(\%hash, 'path'), 'Single Bwa version in list context');

    %hash = $class->_lookup_version();
    ok(_has_key(\%hash, 'bwa'), 'All Bwa versions in list context');

    %hash = $class->_lookup_version('foo');
    is(%hash, 0, 'Invalid version is undef in list context');

    my $default = $class->default_version;
    is($default, '0.5.9', "Correct default is returned");
}

sub test_verify_bwa_version {
    eval { $class->_verify_bwa_version('does-not-exist'); };
    ok($@ =~ /No knowledge of bwa version does-not-exist/, 'Version does not exist');

    eval { $class->_verify_bwa_version('invalid-key'); };
    ok($@ =~ /Invalid version hash for bwa version invalid-key/, 'Invalid keys in version hash');

    eval { $class->_verify_bwa_version('missing-keys'); };
    ok($@ =~ /Invalid version hash for bwa version missing-keys/, 'Missing keys in version hash');

    eval { $class->_verify_bwa_version('invalid-features'); };
    ok($@ =~ /Invalid feature foo for bwa version invalid-features/, 'Invalid features detected');

    eval { $class->_verify_bwa_version('invalid-log-format'); };
    ok($@ =~ /Invalid log format foo for bwa version invalid-log-format/, 'Invalid log format detected');

    eval { $class->_verify_bwa_version('invalid-index-type'); };
    ok($@ =~ /Invalid index type foo for bwa version invalid-index-type/, 'Invalid index type detected');
}

sub test_features {
    # test features
    my @features = qw(bam_input multiple_reference_mode mem bwasw);
    my $supports;

    $supports = $class->supports_bam_input('all-features-new-logs-skips-reverse');
    is($supports, 1, 'Supports bam input');

    $supports = $class->supports_multiple_reference('all-features-new-logs-skips-reverse');
    is($supports, 1, 'Supports multiple reference');

    $supports = $class->supports_mem('all-features-new-logs-skips-reverse');
    is($supports, 1, 'Supports mem');

    $supports = $class->supports_bwasw('all-features-new-logs-skips-reverse');
    is($supports, 1, 'Supports bwasw');

    $supports = $class->supports_bam_input('no-features-old-logs-includes-reverse');
    is($supports, 0, 'Does not support bam input');

    $supports = $class->supports_multiple_reference('no-features-old-logs-includes-reverse');
    is($supports, 0, 'Does not support multiple reference');

    $supports = $class->supports_mem('no-features-old-logs-includes-reverse');
    is($supports, 0, 'Does not support mem');

    $supports = $class->supports_bwasw('no-features-old-logs-includes-reverse');
    is($supports, 0, 'Does not support bwasw');


    # test log format
    my $log_format;

    $log_format = $class->log_format('all-features-new-logs-skips-reverse');
    is($log_format, 'new', 'New log format');

    $log_format = $class->log_format('no-features-old-logs-includes-reverse');
    is($log_format, 'old', 'Old log format');


    # test index extensions
    my @extensions;

    @extensions = $class->index_extensions('all-features-new-logs-skips-reverse');
    ok(not (grep { $_ eq 'rbwt' } @extensions), 'Skips reverse extensions');
    is(@extensions, 5, 'Correct number of extensions');

    @extensions = $class->index_extensions('no-features-old-logs-includes-reverse');
    ok((grep { $_ eq 'rbwt' } @extensions), 'Includes reverse extensions');
    is(@extensions, 8, 'Correct number of extensions');
}

sub test_misc {
    # test path
    my $path;

    $path = $class->path_for_bwa_version('all-features-new-logs-skips-reverse');
    is($path, '/path/to/bwa', 'Path to bwa version');

    # test available versions
    my @available = $class->available_bwa_versions;
    my @expected_versions = keys %custom_versions;
    my $found_all = 1;
    for my $expected (@expected_versions) {
        if (not grep { $expected eq $_ } @available) {
            $found_all = 0;
            last;
        }
    }
    ok($found_all, 'All expected versions found');
}

# run tests

test_lookup_version();

# override _bwa_version for the rest of the tests
*Genome::Model::Tools::Bwa::_lookup_version = sub {
    my $class = shift;
    my $version = shift;

    # see above
    my %bwa_versions = %custom_versions;

    if ($version) {
        my $result = $bwa_versions{$version};
        return unless $result; # undef if version does not exist
        return wantarray ? %$result : $result;
    } else {
        return wantarray ? %bwa_versions : \%bwa_versions;
    }
};

test_verify_bwa_version();
test_features();
test_misc();

done_testing();

1;
