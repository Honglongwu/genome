#!/gsc/bin/perl

BEGIN { 
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
}

use strict;
use warnings;

use above "Genome";
use Test::More;
use Genome::Utility::Test;

my $class = "Genome::Model::Tools::Annotate::Sv::Base";
use_ok($class);

my $data_dir = Genome::Utility::Test->data_dir($class);
my $version = 1;
my $base_dir = join("/", $data_dir, "v$version");

{#read_in_ucsc_annotator builds up the desired data structure
my $expected_structure = {
    1 => [
    {
        bin => "11",
        chrom => "1",
        bpA => "20971165",
        bpB => "20972052",
        name => "rs71646557",
        extra => ["some","other","columns"],
    },
    {
        bin => "11",
        chrom => "1",
        bpA => "20971170",
        bpB => "20972052",
        name => "rs71646558",
        extra => ["some","other","columns"],
    },
    ],
    X => [
    {
        bin => "11",
        chrom => "X",
        bpA => "2097117",
        bpB => "2097205",
        name => "rs71646559",
        extra => ["some","other","columns"],
    },
    ],
};
my $file = join("/", $base_dir, "example_ucsc");
my $annot = Genome::Model::Tools::Annotate::Sv::Base->read_ucsc_annotation($file);

is_deeply($annot, $expected_structure, "Ucsc annotation file was read as expected") or diag explain [$annot, $expected_structure];
}

{
#annotate_interval_matches
my $annotation_struct = {
    X =>
    [
    load_annotation(1),
    ],
};

test_annotate_interval_overlaps($annotation_struct, 2097117, 2097205, 1, 1, "Interval matches exactly");
test_annotate_interval_overlaps($annotation_struct, 2097116, 2097205, 1, 1, "Interval starts before 1st breakpoint and ends at 2nd");
test_annotate_interval_overlaps($annotation_struct, 2097116, 2097206, 1, 1, "Interval spans both breakpoints");
test_annotate_interval_overlaps($annotation_struct, 2097117, 2097204, 1, 0, "Interval matches 1st breakpoint but not second");
test_annotate_interval_overlaps($annotation_struct, 2097118, 2097206, 0, 1, "Interval matches 2nd breakpoint but not first");
test_annotate_interval_overlaps($annotation_struct, 2097206, 2097220, 0, 0, "Interval falls after 2nd breakpoint");
test_annotate_interval_overlaps($annotation_struct, 2097114, 2097207, 1, 1, "Interval spans both breakpoints");
test_annotate_interval_overlaps($annotation_struct, 2097118, 2097203, 0, 0, "Interval falls entirely within");
}
{#more complicated annotation_struct
my $annotation_struct = {
    X =>
    [
    load_annotation(1),
    load_annotation(2),
    ],
};
test_annotate_interval_overlaps($annotation_struct, 2097117, 2097203, 1, 0, "Interval matches 1st annotation");
test_annotate_interval_overlaps($annotation_struct, 2107117, 2107203, 2, 0, "Interval matches 2nd annotation, bpA");
test_annotate_interval_overlaps($annotation_struct, 2107120, 2107206, 0, 2, "Interval matches 2nd annotation, bpB");
}

{#test get_var_annotation
my $position = load_positions(2097117, 2097205);
my $annot1 = load_annotation(1);
my $annot2 = load_annotation(2);
my $annot3 = load_annotation(3);
my $annot4 = load_annotation(4);

is(Genome::Model::Tools::Annotate::Sv::Base->get_var_annotation($position->{"X"}->[0], [$annot1], undef, 0), "TEST1", "get_var_annotation with 1 valid overlap");
is(Genome::Model::Tools::Annotate::Sv::Base->get_var_annotation($position->{"X"}->[0], undef, [$annot1], 0), "TEST1", "get_var_annotation with 1 valid overlap");
is(Genome::Model::Tools::Annotate::Sv::Base->get_var_annotation($position->{"X"}->[0], [$annot1], [$annot1], 0), "TEST1", "get_var_annotation with 1 valid overlap");
is(Genome::Model::Tools::Annotate::Sv::Base->get_var_annotation($position->{"X"}->[0], [$annot1, $annot4], undef, 0), "TEST1,TEST4", "get_var_annotation with 2 valid overlaps");
is(Genome::Model::Tools::Annotate::Sv::Base->get_var_annotation($position->{"X"}->[0], undef, undef, 0), "N/A", "get_var_annotation with no valid overlaps");
is(Genome::Model::Tools::Annotate::Sv::Base->get_var_annotation($position->{"X"}->[0], [$annot2], undef, 0), "N/A", "get_var_annotation with 1 invalid overlap");
is(Genome::Model::Tools::Annotate::Sv::Base->get_var_annotation($position->{"X"}->[0], [$annot3], undef, 0), "N/A", "get_var_annotation with annotation on the wrong chromosome");
}
done_testing;

sub test_annotate_interval_overlaps {
    my ($annotation_struct, $bpA, $bpB, $expected_to_match_a, $expected_to_match_b, $message) = @_;
    my $positions = load_positions($bpA, $bpB);
    my $post_positions;
    if ($expected_to_match_a or $expected_to_match_b) {
        $post_positions = load_positions_with_match($bpA, $bpB, $expected_to_match_a, $expected_to_match_b);
    }
    else {
        $post_positions = load_positions($bpA, $bpB);
    }
    my $tag = "TEST";

    ok(Genome::Model::Tools::Annotate::Sv::Base->annotate_interval_overlaps(
        $positions, $annotation_struct, $tag,
    ), "Successfully ran with $bpA, $bpB");
    is_deeply($positions, $post_positions, $message);
}

sub load_positions {
    my ($bpA, $bpB) = @_;
    return {
        X => [
        {
            chrA => "X",
            bpA => $bpA,
            chrB => "X",
            bpB => $bpB,
            event => "DEL",
            orient => "+-",
        },
        ],
    };
}

sub load_positions_with_match {
    my ($bpA, $bpB, $ea, $eb) = @_;
    my $pos = load_positions($bpA, $bpB);
    my $load;
    if ($ea) {
        $load = load_annotation($ea);
        die("Unknown expected annotation - should be 0,1, or 2") unless $load;
        $pos->{"X"}->[0]->{"TEST"}->{"bpA"} = [$load];
    }
    if ($eb) {
        $load = load_annotation($eb);
        die("Unknown expected annotation - should be 0,1, or 2") unless $load;
        $pos->{"X"}->[0]->{"TEST"}->{"bpB"} = [$load];
    }
    return $pos;
}

sub load_annotation {
    my $index = shift;
    my %annotations = ( 
    1 => {
        bin => "11",
        chrom => "X",
        bpA => "2097117",
        bpB => "2097205",
        name => "TEST1",
    },
    2 => {    
        bin => "11",
        chrom => "X",
        bpA => "2107117",
        bpB => "2107205",
        name => "TEST2",

    },
    3 => {    
        bin => "11",
        chrom => "9",
        bpA => "2097117",
        bpB => "2097205",
        name => "TEST3",

    },
    4 => {
        bin => "11",
        chrom => "X",
        bpA => "2097117",
        bpB => "2097205",
        name => "TEST4",
    },
    );
    return $annotations{$index};
}
