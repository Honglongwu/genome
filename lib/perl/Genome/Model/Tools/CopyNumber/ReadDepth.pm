package Genome::Model::Tools::CopyNumber::ReadDepth;

use strict;
use Genome;
use IO::File;
use Statistics::R;
use File::Basename;
use warnings;
require Genome::Sys;
use FileHandle;
use File::Spec;

class Genome::Model::Tools::CopyNumber::ReadDepth{
    is => 'Command',
    has => [

	bins => {
	    is => 'String',
	    is_optional => 1,
	    doc => 'bins file to get reads from (output of gmt copy-number bam-window)',
	},

	bam => {
	    is => 'String',
	    is_optional => 1,
            doc => 'bam file (not needed if --bins is specified)',
	},

        bin_size => {
            is => 'Integer',
            is_optional => 1,
            doc => 'Choose the bin size to use for read counts. Default 10k',
            #todo: script will determine an optimal size',
            default => '10000',
        },

        # tumor_read_length => {
        #     is => 'String',
        #     is_optional => 1,
        #     doc =>'tumor read length (can be one integer or a comma-separated list)',
        # },

        # normal_read_length => {
        #     is => 'String',
        #     is_optional => 1,
        #     doc =>'normal read length (can be one integer or a comma-separated list)',
        # },

        # output_map_corrected_bins => {
        #     is => 'Boolean',
        #     is_optional => 1,
        #     doc =>'output a listing of the bins and their read-depths after mapability correction',
        #     default => 0,
        # },

        # do_segmentation => {
        #     is => 'Boolean',
        #     is_optional => 1,
        #     doc =>'run segmentation on the bins to get discrete regions of copy number (CBS algorithm)',
        #     default => 1,
        # },

        # do_plotting => {
        #     is => 'Boolean',
        #     is_optional => 1,
        #     doc =>'output a whole-genome plot',
        #     default => 1,
        # },

        output_directory => {
            is => 'String',
            is_optional => 0,
            doc =>'path to the output directory',
        },

        annotation_directory => {
            is => 'String',
            is_optional => 0,
            doc =>'path to the annotation directory that contains all the different readlength annotations',
        },

        cnvseg_output => {
            is => 'Boolean',
            is_optional => 1,
            default => 1,
            doc =>'tweak the output to be compatible with cnvSeg (cnvHMM)',
        },

        per_lib => {
            is => 'Boolean',
            is_optional => 1,
            default => 1,
            doc =>'get window counts and do normalization on a per-library basis',
        },

        min_mapability => {
            is => 'Float',
            is_optional => 1,
            default => 0.60,
            doc =>'the minimum fraction of a window that must be mappable in order to be considered',
        },

        genome_build => {
            is => 'String',
            is_optional => 0,
            doc =>'genome build - one of "hg18", "hg19", or "mm9"',
        },

        snp_file => {
            is => 'String',
            is_optional => 1,
            doc =>'het snp sites from the genome in gmt bam-readcount format (chr, st, ref, var, refReads, varReads, VAF)',
        },

        just_output_script_files => {
            is => 'Boolean',
            is_optional => 1,
            default => 0,
            doc =>"don't run the R script, just prep everything and dump it into the output directory",
        },
        

        processors => {
            is => 'Integer',
            is_optional => 1,
            default => 1,
            doc => "set the number of processors that the parallel steps will use",
        },

        sex => {
            is => 'String',
            is_optional => 0,
            doc =>'sex of the patient - "male" or "female"',
            default => "male",
        },

        

        ]
};

sub help_brief {
    "Takes two bin files generated by bam-window. Creates the necessary params files, then runs the R readDepth package to correct the data for mapability and GC content bias."
}

sub help_detail {
    "Takes two bin files generated by bam-window. Creates the necessary params files, then runs the R readDepth package to correct the data for mapability and GC content bias."
}

#########################################################################

sub printCoreCode{
    my ($output_directory, $rl, $type, $RFILE) = @_;
    my $name = "rdo." . $type . "." . $rl;
    print $RFILE "PARAMSFILE <<- \"" . $output_directory . "/params.$type.$rl\"\n";
    print $RFILE "verbose <<- TRUE\n";
    print $RFILE "$name = new(\"rdObject\")\n";
    print $RFILE "$name = readDepth($name)\n";
    print $RFILE "$name = rd.mapCorrect($name, minMapability=0.60)\n";
    print $RFILE "$name = rd.gcCorrect($name)\n";
    print $RFILE "$name = mergeLibraries($name)\n";
}

#--------------------------------
sub bamWindowCmd{
    my ($bam1, $name1, $output_directory, $per_lib, $bin_size)= @_;
    
    #We're going to save some time by sending it to the cluster.
    my $cmd = "perl -I ~cmiller/gscCode/genome/lib/perl /gsc/scripts/opt/genome/current/user/bin/gmt copy-number bam-window --bam-file " . $bam1;
    $cmd .= " --output-file $output_directory/" . $name1 . ".bins";
    if($per_lib){
        $cmd .= " --per-lib";
    }
    $cmd .= " --per-read-length"; 
    $cmd .= " --window-size $bin_size"; 
#    $cmd .= " --lib-as-readgroup"
    
    return($cmd);
    
}

#------------------------------------
sub getReadLengths{
    my ($binfile) = @_;
    
    my $cmd = "head -n 1 $binfile";
    open(HEADER,"$cmd |") || die "unable to open $binfile\n";
    while(<HEADER>){
        my @F = split("\t",$_);
        my %lengths;
        foreach my $lib (@F[2..$#F]){
            if($lib =~ /\.(\d+)$/){
                $lengths{$1} = 0;
            } else {
                die("unrecognized lib name: $lib\n");
            }
        }
        return(join(",",keys(%lengths)));
    }
}

#########################################################################

sub execute {
    my $self = shift;

    my $bam = $self->bam;
    my $bins = $self->bins;
#    my $output_map_corrected_bins = $self->output_map_corrected_bins;
    my $output_directory = $self->output_directory;
    my $annotation_directory = $self->annotation_directory;
    my $cnvseg_output = $self->cnvseg_output;
    my $per_lib = $self->per_lib;
    my $bin_size = $self->bin_size;
    my $genome_build = $self->genome_build;
    my $snp_file = $self->snp_file;
    my $sex = $self->sex;
    
    if (lc($sex) eq "m"){
        $sex="male";
    } elsif (lc($sex) eq "f"){
        $sex="female";
    }


    #do windowing unless bins are present    
    if(defined($bam) && !(defined($bins))){
        my $cmd = bamWindowCmd($bam,"sample",$output_directory, $per_lib, $bin_size);
        $bins = $output_directory . "/sample.bins";
        system("$cmd");
    }

    #extract the read lengths from the header of the bin files.
    my @read_lengths = split(",",getReadLengths($bins));


    #resolve relative paths to full path
    $output_directory = File::Spec->rel2abs($output_directory);
    `mkdir -p $output_directory/vafplots`;

    $annotation_directory = File::Spec->rel2abs($annotation_directory);
    if(defined($snp_file)){
        $snp_file = File::Spec->rel2abs($snp_file);
    }

    #open the r file
    my $rf = open(my $RFILE, ">$output_directory/run.R") || die "Can't open R file for writing.\n";
    print $RFILE "library(readDepth)\n";

    my $type = "sample";

    foreach my $rl (@read_lengths){
        my $annotation_path = $annotation_directory . "/" . $genome_build . "." . $rl  . "." . $sex;
        unless ( -d $annotation_path){
            die("no annotations matching $annotation_path");
        }
        
        #write params file
        my $pf = open(PARAMSFILE1, ">$output_directory/params." . $type . "." . $rl) || die "Can't open params file.\n";
        print PARAMSFILE1 "readLength\t$rl\n";
        print PARAMSFILE1 "fdr\t0.01\n";
        print PARAMSFILE1 "verbose\tTRUE\n";
        print PARAMSFILE1 "overDispersion\t3\n";
        print PARAMSFILE1 "gcWindowSize\t100\n";
        print PARAMSFILE1 "percCNGain\t0.05\n";
        print PARAMSFILE1 "percCNLoss\t0.05\n";
        print PARAMSFILE1 "maxCores\t" . $self->processors . "\n";
        print PARAMSFILE1 "outputDirectory\t$output_directory\n";
        print PARAMSFILE1 "annotationDirectory\t" . $annotation_path . "\n";
        print PARAMSFILE1 "binSize\t$bin_size\n";
        
        print PARAMSFILE1 "inputType\tbins\n";
        $bins = File::Spec->rel2abs($bins);
        print PARAMSFILE1 "binFile\t$bins\n";
        
        if($per_lib){
            print PARAMSFILE1 "perLib\tTRUE\n";
        }            
        if(@read_lengths > 1){
            print PARAMSFILE1 "perLibLengths\tTRUE\n";
        }
        
        if(defined($snp_file)){
            print PARAMSFILE1 "dbSnpVaf\t$snp_file\n";
        }
        close(PARAMSFILE1);

        #now dump the appropriate code to the R file
        printCoreCode($output_directory, $rl, $type, $RFILE);
    }

    #merge the data from different read lengths
    my $i;
    print $RFILE "rdo.sample = rdo.sample." . $read_lengths[0] . "\n";
    for($i=1; $i < @read_lengths; $i++){
        print $RFILE "rdo.sample = addObjectBins(rdo.sample," . "rdo.sample." . $read_lengths[$i] . ")\n";
    }

    if(defined($snp_file)){
        print $RFILE "rdo.sample" . '@binParams$med = calculateMedianFromDbsnpSites(rdo.sample, 2000000, peakWiggle=4)' . "\n";
    }

    if($cnvseg_output){
        print $RFILE "writeBins(rdo.$type,file=\"$output_directory/" . $type . "Bins\",cnvHmmFormat=TRUE)\n";
    } else {
        print $RFILE "writeBins(rdo.$type,file=\"$output_directory/" . $type . "Bins\")\n";
    }


    #print cnvhmm input file 
    print $RFILE "writeCnvhmmInput(rdo.$type)\n";
    close($RFILE);
    
    if($self->just_output_script_files){
        return 1;
    }
    
    #drop into the output directory to make running the R script easier
    chdir $output_directory;
    my $cmd = "Rscript run.R";
    my $return = Genome::Sys->shellcmd(
        cmd => "$cmd",
        );
    unless($return) {
        $self->error_message("Failed to execute: Returned $return");
        die $self->error_message;
    }
    return $return;

}
1;
