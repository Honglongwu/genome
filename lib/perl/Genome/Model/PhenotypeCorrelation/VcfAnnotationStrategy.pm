package Genome::Model::PhenotypeCorrelation::VcfAnnotationStrategy;

use Genome;
use Parse::RecDescent;
use Carp qw/confess/;

use strict;
use warnings;

# This module defines a grammar for specifying vcf annotation strategies for use with Joinx.
#
# The main components of any strategy are:
# (1) Specification of the source
# (2) Optional list of info fields
#
# The source may be specified in one of two ways:
#
# (a) source x version y
#     This will attempt to find a unique vcf file like so:
#       Genome::Model::Build::ImportedVariationList->get(source_name => 'x', version => 'y')->snvs_vcf
# (b) build 12345
#     This generates the query
#       Genome::Model::Build->get(12345)->snvs_vcf
#
# The (optional) info field specification should be a colon separated list of info field values
# suitable for passing to joinx vcf-annotate. Joinx can perform info field renaming as well as
# applying info fields on a per-alternate allele basis (annotating only the alleles that match
# the annotation source). Here is an example info field specification:
#
# dbSNPBuildId=dbsnp,per-alt:PM:MUT
#
# This means copy the dbSNPBuildId field from the annotation source to the target file, renaming it
# to dbsnp for any alt alleles that intersect the source, and copy PM and MUT from the annotation
# file on a per-site basis.

my $grammar = q{
    startrule: strategy end
        { $item[1]; }
    | <error>

    end: /^\Z/

    strategy: annotation_source ";" strategy
            { $return = [$item[1], @{$item[3]}]; }
    | annotation_source
            { $return = [$item[1]]; }

    annotation_source:
        "build" word info_spec(?)
            {
                $return = {
                    source_build => $item[2],
                    info => @{$item[3]} ? $item[3]->[0] : undef
                    };
            }
        | "source" word "version" word info_spec(?)
            {
                $return = {
                    source_name => $item[2],
                    source_version => $item[4],
                    info => @{$item[5]} ? $item[5]->[0] : undef
                    };
            }
        | <error>

    word: /([\w\.:-]|\\\\)+/ { $return = $item[1]; }

    info_spec: "info" /([^\s<>])+/ { $return = $item[2]; }
};

class Genome::Model::PhenotypeCorrelation::VcfAnnotationStrategy {
    is => "Command::V2",
    has_input => [
        strategy => {
            is => "Text",
            doc => "The strategy defining the sequence of vcf annotations to perform",
        },
    ],
    has_optional_output => [
        tree => {
            is => 'HASH',
            doc => 'The parse tree generated by the strategy',
        },
    ],
};

my $parser;

sub execute {
    my $self = shift;
    $parser = Parse::RecDescent->new($grammar) unless $parser;
    $self->tree($parser->startrule($self->strategy));
    return $self->tree;
}

1;
