#!/usr/bin/env genome-perl

use strict;
use warnings;

BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
    $ENV{UR_COMMAND_DUMP_STATUS_MESSAGES} = 1;
}

use above 'Genome';

use Test::More;

use_ok('Genome::Model::Command::Services::AssignQueuedInstrumentData') or die;

my ($cnt, @samples, @instrument_data);
no warnings;
*Genome::InstrumentDataAttribute::get = sub {
    my ($class, %params) = @_;
    my %attrs = map { $_->id => $_ } map { $_->attributes } @instrument_data;
    for my $param_key ( keys %params ) {
        my @param_values = ( ref $params{$param_key} ? @{$params{$param_key}} : $params{$param_key} );
        my @unmatched_attrs;
        for my $attr ( values %attrs ) {
            next if grep { $attr->$param_key eq $_ } @param_values;
            push @unmatched_attrs, $attr->id;
        }
        for ( @unmatched_attrs ) { delete $attrs{$_} }
    }
    return values %attrs;
};
use warnings;

# PROJECTS
# research project
my @projects;
push @projects, Genome::Project->create(id => -444, name => '__TEST_PROJECT__');
ok($projects[0], 'create project for research project');
my $pp_id = 2732557;
$projects[0]->add_part(label => 'default_processing_profiles', entity_id => $pp_id, entity_class_name => 'Genome::ProcessingProfile');
my $part = $projects[0]->parts(label => 'default_processing_profiles');
is($part->entity_id, $pp_id, 'set pp id on project');
# work order
push @projects, Genome::Project->create(id => -222, name => '__TEST_WORKORDER__');
ok($projects[1], 'create project for work order');
# Model groups for projects
my @model_groups = Genome::ModelGroup->get(uuid => [ map { $_->id } @projects ]);
is(@model_groups, 2, 'created model groups');

my $bac_source = Genome::Individual->__define__(
    name => '__TEST_BAC_SOURCE__', 
    taxon => Genome::Taxon->__define__(name => 'bacteria', domain => 'Bacteria', species_latin_name => 'T. bacteria'),
);
ok($bac_source, 'define bacteria source');
ok($bac_source->taxon, 'define bacteria taxon');
my $unknown_source = Genome::Individual->__define__(
    name => '__TEST_UNKNOWN__SOURCE_',
    taxon => Genome::Taxon->__define__(name => 'unknown', domain=> 'unknown', species_latin_name => 'unknown'),
);
ok($unknown_source, 'define unknown source');
ok($unknown_source->taxon, 'define unknown taxon');
my $pp = Genome::ProcessingProfile->get(2658559);
ok($pp, 'got de novo pp');
ok(_create_inst_data($bac_source), 'create inst data for bacteria taxon');
ok(_create_inst_data($unknown_source), 'create inst data for unknown');
is(@instrument_data, $cnt, "create $cnt inst data");
is_deeply(
    [ map { $_->attribute_value } map { $_->attributes(attribute_label => 'tgi_lims_status') } @instrument_data ],
    [ map { 'new' } @instrument_data ],
    'set tgi_lims_status to new',
);

my $cmd = Genome::Model::Command::Services::AssignQueuedInstrumentData->create;
ok($cmd, 'create aqid');
ok($cmd->execute, 'execute');
my @new_models = values %{$cmd->_newly_created_models};
my %new_models = _model_hash(@new_models);
my @existing_models = values %{$cmd->_existing_models_assigned_to};
my %existing_models = _model_hash(@existing_models);
#print Data::Dumper::Dumper(\%new_models,\%existing_models);
is_deeply(
    \%new_models,
    {
        "AQID-testsample1.bacteria.prod-denovo.wugc" => {
            subject => $samples[0]->name,
            processing_profile_id => 2732557,
            inst => [ $instrument_data[0]->id ],
            auto_assign_inst_data => 1,
            projects => [ sort map { $_->id } @projects ],
            model_groups => [ sort map { $_->id } @model_groups ],
        },
        "AQID-testsample2.unknown.prod-denovo.wugc" => {
            subject => $samples[1]->name,
            processing_profile_id => 2732557,
            inst => [ $instrument_data[1]->id ],
            auto_assign_inst_data => 1,
            projects => [ sort map { $_->id } @projects ],
            model_groups => [ sort map { $_->id } @model_groups ],
        },
    },
    'new models',
);

my @processed_instrument_data = grep { $_->attributes(attribute_label => 'tgi_lims_status')->attribute_value eq 'processed' } @instrument_data;
is(
    @processed_instrument_data,
    2,
    'set tgi lims status to processed for all instrument data',
);

done_testing();
exit;

sub _create_inst_data {
    my $source = shift;
    $cnt++;
    my $sample = Genome::Sample->__define__(
        name => 'AQID-testsample'.$cnt.'.'.lc($source->taxon->name),
        source => $source,
        extraction_type => 'genomic',
    );
    ok($sample, 'sample '.$cnt);
    push @samples, $sample;
    my $library = Genome::Library->__define__(
        name => $sample->name.'-testlib',
        sample_id => $sample->id,
    );
    ok($library, 'create library '.$cnt);

    my $instrument_data = Genome::InstrumentData::Solexa->__define__(
        library_id => $library->id,
    );
    ok($instrument_data, 'created instrument data '.$cnt);
    push @instrument_data, $instrument_data;
    $instrument_data->add_attribute(
        attribute_label => 'tgi_lims_status',
        attribute_value => 'new',
    );
    for my $project ( @projects ) {
        $project->add_part(
            entity_id => $instrument_data->id,
            entity_class_name => 'Genome::InstrumentData',
            label => 'instrument_data',
        );
    }

    return 1;
}

sub _model_hash {
    return map { 
        $_->name => { 
            subject => $_->subject_name, 
            processing_profile_id => $_->processing_profile_id,
            inst => [ sort map { $_->id } $_->instrument_data ],
            auto_assign_inst_data => $_->auto_assign_inst_data,
            projects => [ sort map { $_->id } $_->projects ],
            model_groups => [ sort map { $_->id } $_->model_groups ],
        }
    } @_;
}

