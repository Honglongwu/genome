#!/usr/bin/env genome-perl

use strict;
use warnings;

BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
}

use above 'Genome';
use Test::More tests => 3;

use Genome::Utility::Test qw(is_equal_set);
use Data::UUID;
use List::Util qw(reduce);

use_ok('Genome::Model::Command::Services::BuildQueuedModels') or die;

subtest 'channel_for_model spreads evenly over all channels' => sub {
    my $channels = 10;
    plan tests => ($channels + 2);

    use_ok('Genome::Model::Command::Services::BuildQueuedModels');

    my $method = \&Genome::Model::Command::Services::BuildQueuedModels::channel_for_model;

    my $ug = Data::UUID->new();

    my %count;
    for (my $s = 0; $s < 10_000; $s++) {
        my $id = $ug->create_hex();
        my $channel = $method->($id, $channels);
        $count{$channel}++;
    }

    my @channels = sort keys %count;
    is_deeply(\@channels, [0..($channels - 1)], 'all channels were used and is zero-based');

    my $sum = reduce { our $a + our $b } values %count;
    my $avg = $sum / scalar(keys %count);

    for my $channel (@channels) {
        my $delta = abs($count{$channel} - $avg);
        my $ndelta = $delta / $avg;
        ok($ndelta < 0.2, "$channel within acceptable range") or diag 'delta = ' . $delta, "\n", 'ndelta = ' . $ndelta;
    }
};

subtest 'original test' => sub {
    plan tests => 19;

    class Genome::ProcessingProfile::Tester {
        is => 'Genome::ProcessingProfile',
    };
    sub Genome::ProcessingProfile::Tester::sequencing_platform { return 'solexa'; };

    class Genome::Model::Tester {
        is => 'Genome::ModelDeprecated',
    };

    class Genome::Model::Build::Tester {
        is => 'Genome::Model::Build',
    };
    sub Genome::Model::Build::Tester::start { my $self = shift; $self->model->build_requested(0); return 1; };

    # PP
    my $pp = Genome::ProcessingProfile->create(
        name => 'Tester PP',
        type_name => 'tester',
    );
    ok($pp, 'create processing profile') or die;

    # SUBJECT 
    my $sample = Genome::Sample->create(
        id => -654321,
        name => 'TEST-00',
    );
    ok($sample, 'create sample') or die;

    my $count;
    my $create_model = sub {
        $count++;
        my $model = Genome::Model->create(
            name => 'Tester Model' . $count,
            processing_profile => $pp,
            subject_id => $sample->id,
            subject_class_name => $sample->class,
            @_);
        ok($model, 'created model ' . $count);
        return $model;
    };


    my @requested_models = map { $create_model->(build_requested => 1) } (1..2);
    my $unrequested_model = $create_model->();

    my @model_ids = map { $_->id } (@requested_models, $unrequested_model);
    my @models = Genome::Model->get(id => \@model_ids);
    ok(@models, 'created models');

    # Lazy hack to deal with assumptions previously used, i.e. that IDs were
    # sorted chronologically.
    @models = ($requested_models[0], $unrequested_model, $requested_models[1]);

    # overload models get and locking
    no warnings qw(redefine once);
    *Genome::Model::get = sub {
        package Genome::Model; 
        my $self = shift;
        my @params = @_;

        #this order matters
        unshift @params, (id => \@model_ids) if @_ != 1;
        return $self->SUPER::get(@params);
    };
    *Genome::Model::create_iterator = sub { 
        package Genome::Model;
        my $self = shift;
        return $self->SUPER::create_iterator(id => \@model_ids, @_);
    };
    *Genome::Sys::lock_resource = sub{ return 1; };
    *Genome::Sys::unlock_resource= sub{ return 1; };
    use warnings;

    is_equal_set(
        [map { $_->id } Genome::Model->get(build_requested => 1)],
        [map { $_->id } @requested_models],
        'models get overloaded') or die;
    ok(Genome::Sys->lock_resource, 'lock_resource overloaded') or die;
    ok(Genome::Sys->unlock_resource, 'unlock_resource overloaded') or die;

    my $command_1 = Genome::Model::Command::Services::BuildQueuedModels->create();
    isa_ok($command_1, 'Genome::Model::Command::Services::BuildQueuedModels');
    ok($command_1->execute(), 'executed build command');
    is_deeply([ map { $_->build_requested ? 1 : 0 } @models ], [qw/ 0 0 0 /], 'builds no longer requested for models');
    my @b0 = $models[0]->builds;
    my @b1 = $models[1]->builds;
    my @b2 = $models[2]->builds;
    is_deeply([ scalar(@b0), scalar(@b1), scalar(@b0)], [qw/ 1 0 1 /], 'created builds for those models that had builds requested');


    $models[1]->build_requested(1);
    is_deeply([ map { $_->build_requested } @models ], [qw/ 0 1 0 /], 'builds requested for one model');
    UR::Context->commit();
    is_deeply([ Genome::Model->get(build_requested => 1) ], [ $models[1] ], 'models get overloaded') or die;
    no warnings qw(redefine);
    *Genome::Model::Build::Tester::start = sub { my $self = shift; $self->model->build_requested(0); $self->error_message('testing failure'); $self->status('Unstartable'); return; };
    use warnings;

    my $command_2 = Genome::Model::Command::Services::BuildQueuedModels->create();
    isa_ok($command_2, 'Genome::Model::Command::Services::BuildQueuedModels');
    $command_2->dump_status_messages(1);
    ok(!$command_2->execute(), 'executed build command but returned false due to errors');
    is_deeply([ map { $_->build_requested } @models ], [qw/ 0 0 0 /], 'builds no longer requested for models');
    @b1 = $models[1]->builds;
    is(scalar(@b1), 1, 'created build for the model that had build requested');
};
