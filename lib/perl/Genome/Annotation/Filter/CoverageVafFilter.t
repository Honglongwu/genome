#!/usr/bin/env genome-perl

use strict;
use warnings;

BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
}

use above 'Genome';
use Genome::Annotation::Expert::BamReadcount::TestHelper;
use Genome::File::Vcf::Entry;
use Test::More;
use Test::Exception;

my $pkg = 'Genome::Annotation::Filter::CoverageVafFilter';
use_ok($pkg) or die;

my $entry = Genome::Annotation::Expert::BamReadcount::TestHelper::create_entry(
    Genome::Annotation::Expert::BamReadcount::TestHelper::bam_readcount_line(),
);

subtest "test pass" => sub { #FIXME

    my $filter = $pkg->create(
        sample_name => 'S1',
        coverages_and_vafs => [qw/ 400:10 300:5 1:0 /],
    );
    lives_ok(sub {$filter->validate}, "Filter validates ok");

    my %expected_return_values = (
        C => 0,
        G => 1,
    );
    is_deeply({$filter->filter_entry($entry)}, \%expected_return_values, "Sample 1 return values as expected");

};

subtest "test filter fail" => sub { #FIXME

    my $filter = $pkg->create(
        sample_name => 'S1',
        coverages_and_vafs => [qw/ 300:100 1:0 /],
    );
    lives_ok(sub {$filter->validate}, "Filter validates ok");

    my %expected_return_values = (
        C => 0,
        G => 0,
    );
    is_deeply({$filter->filter_entry($entry)}, \%expected_return_values, "Sample 1 return values as expected");

};

subtest 'validate fails' => sub {

    my $filter = $pkg->create(sample_name => 'S1');
    throws_ok( sub{ $filter->validate; }, qr/^Failed to validate/, "failed to validate when coverages_and_vafs is undef");

    $filter = $pkg->create(coverages_and_vafs => [qw/ 20:5 10:10 1:0 /]);
    throws_ok( sub{ $filter->validate; }, qr/^Failed to validate/, "failed to validate when sample_name is undef");

    $filter = $pkg->create(
        sample_name => 'S1',
        coverages_and_vafs => [qw/ STRING:10 0:1 /],
    );
    throws_ok( sub{ $filter->validate; }, qr/^Failed to validate/, "failed to validate when coverages_and_vafs coverage is a string" );

};

done_testing();
