#!/usr/bin/env genome-perl

use strict;
use warnings FATAL => 'all';

use Test::More;
use above 'Genome';
use Genome::Utility::Test qw(compare_ok);
use Test::Exception;

BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
};

my $pkg = 'Genome::Annotation::Plan';
use_ok($pkg) || die;

sub test_bad_plan {
    my $name = shift;
    my $error_regex = shift;

    my $filename = $name . '.yaml';

    my $plan_file = plan_file($filename);
    my $plan = $pkg->create_from_file($plan_file);
    ok($plan, sprintf("Made a plan from file ($plan_file)."));

    throws_ok sub {$plan->validate();}, $error_regex,
        "Validation fails for invalid plan ($name).";
}

sub test_bad_yaml {
    my $name = shift;
    my $filename = $name . '.yaml';

    my $plan_file = plan_file($filename);
    throws_ok sub {$pkg->create_from_file($plan_file);}, qr(invalid information),
        "create_from_file fails for invalid yaml ($name).";
}

sub plan_file {
    my $filename = shift;
    return File::Spec->join(__FILE__ . ".d", $filename);
}

{
    package Genome::Annotation::TestInterpreter;

    use strict;
    use warnings FATAL => 'all';
    use Genome;

    class Genome::Annotation::TestInterpreter {
        is => 'Genome::Annotation::InterpreterBase',
        has => [
            ix_p1 => {},
            ix_p2 => {},
        ],
    };

    sub name {
        "interpreter_x";
    }

    sub requires_experts {
        return qw(expert_one);
    }

    1;
}

{
    package Genome::Annotation::AnotherTestInterpreter;

    use strict;
    use warnings FATAL => 'all';
    use Genome;

    class Genome::Annotation::AnotherTestInterpreter {
        is => 'Genome::Annotation::InterpreterBase',
        has => [
            ix_p1 => {},
            ix_p2 => {},
        ],
    };

    sub name {
        "interpreter_y";
    }

    1;
}

{
    package Genome::Annotation::TestReporter;

    use strict;
    use warnings FATAL => 'all';
    use Genome;

    class Genome::Annotation::TestReporter {
        is => 'Genome::Annotation::ReporterBase',
        has => [
            ra_p1 => {},
            ra_p2 => {},
        ],
    };

    sub name {
        "reporter_alpha";
    }

    sub requires_interpreters {
        return qw(interpreter_x);
    }

    1;
}

{
    package Genome::Annotation::TestExpert;

    use strict;
    use warnings FATAL => 'all';
    use Genome;

    class Genome::Annotation::TestExpert {
        is => 'Genome::Annotation::ExpertBase',
        has => [
            e1_p1 => {},
            e1_p2 => {},
        ],
    };

    sub name {
        "expert_one";
    }
}

{
    package Genome::Annotation::AnotherTestExpert;

    use strict;
    use warnings FATAL => 'all';
    use Genome;

    class Genome::Annotation::AnotherTestExpert {
        is => 'Genome::Annotation::ExpertBase',
        has => [
            e1_p1 => {},
            e1_p2 => {},
        ],
    };

    sub name {
        "expert_two";
    }

    1;
}

test_bad_plan('missing_expert', qr(expert_missing) );
test_bad_plan('missing_filter', qr(filter_missing) );
test_bad_plan('missing_interpreter', qr(interpreter_missing) );
test_bad_plan('missing_reporter', qr(reporter_missing) );

test_bad_plan('misspelled_parameter', qr(bad_parameter_name) );

test_bad_plan('invalid_reporter', qr(interpreters do not match) );
test_bad_plan('invalid_experts', qr(do not match experts required) );

test_bad_yaml('invalid_yaml');
done_testing();
